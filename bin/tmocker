#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use POE;
use POE::Wheel::ReadWrite;
use POE::Filter::Stream;
use Data::Serializer;
use IO::Handle;
use Zeta::Log;

my $mocker_name;
my $clock;

my $rtn = GetOptions(
    "mkname|m=s" => \$mocker_name,
    "clock|c"    => \$clock
);

my $logger = Zeta::Log->new(
    logurl   => "file://./tlog/$mocker_name.log",
    loglevel => 'DEBUG',
);

my $logger_send = Zeta::Log->new(
    logurl   => "file://./tlog/$mocker_name.slog",
    loglevel => 'DEBUG',
);

my $logger_recv = Zeta::Log->new(
    logurl   => "file://./tlog/$mocker_name.rlog",
    loglevel => 'DEBUG',
);

POE::Session->create(
    inline_states => {
        _start  => \&on_start,
        on_recv => \&on_recv,
        on_send => \&on_send,
    },
    args => [],
);

$logger->debug(">>>>>>>>>>>$mocker_name running...");
$poe_kernel->run();

sub on_start {

    STDIN->blocking(1);
    $_[HEAP]{recv} = POE::Wheel::ReadWrite->new(
        InputEvent => 'on_recv',
        Handle     => \*STDIN,
    );

    STDOUT->autoflush(1);
    $_[HEAP]{send} = POE::Wheel::ReadWrite->new( Handle => \*STDOUT, );
    $_[HEAP]{rotation} = 1;
    $logger_send->debug(">>>>>>>>rotation.$_[HEAP]{rotation} started");
    $_[KERNEL]->delay( 'on_send' => 1 );
}

sub on_recv {
    $logger_recv->debug( "recv:\n" . Data::Dump->dump( $serializer->thaw( $_[ARG0] ) ) );
}

sub on_send {

    unless (@send) {
        $logger_send->debug("<<<<<<<<rotation.$_[HEAP]{rotation} completed");
        $_[HEAP]{rotation}++;
        if ($clock) {
            $logger_send->debug(">>>>>>>>rotation.$_[HEAP]{rotation} started");
            @send = @mocker_send;
        }
        else {
            kill getppid();
            exit 0;
        }
    }
    my $data      = shift @send;
    my $data_hash = shift @send_hash;
    $logger_send->debug( "snd:\n" . Data::Dump->dump($data_hash) );
    $_[HEAP]{send}->put($data);
    $_[KERNEL]->delay( 'on_send' => 2 );
}

__END__


